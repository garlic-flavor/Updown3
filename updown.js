// Generated by CoffeeScript 2.4.1
(function() {
  //# UP-DOWN3 written by KUMA. licensed under the CC0 2019.

  //#==============================================================================
  // Suger for getter and setter method of CoffeeScript.
  var GSIMap, HeightServer, ImageServer, MyMap, RouteMarker, RouteMarkerGenerator, SVGGenerator, makeSVG;

  Function.prototype.property = function(prop, desc) {
    return Object.defineProperty(this.prototype, prop, desc);
  };

  SVGGenerator = (function() {
    var _NS, _toStyleString;

    //#==============================================================================
    // JQueryを利用し、SVGを生成する。
    class SVGGenerator {
      // paper サイズの空のSVGを生成する。
      constructor(paper) {
        switch (paper) {
          case 'A4':
            this.paperSize = {
              x: 297,
              y: 210
            };
            break;
          default:
            this.paperSize = {
              x: 297,
              y: 210
            };
        }
        this.$svg = this.$NS("svg", {
          xmlns: _NS,
          version: "1.1",
          height: this.paperSize.y + "mm",
          width: this.paperSize.x + "mm",
          viewBox: "0 0 " + this.paperSize.x + " " + this.paperSize.y
        }).append($("<style>"));
        this.lastLayer = this.$svg;
      }

      // SVGの名前空間でDOM要素を作る。
      $NS(elementName, attr) {
        var $elem;
        $elem = $(document.createElementNS(_NS, elementName));
        if (attr != null) {
          return $elem.attr(attr);
        } else {
          return $elem;
        }
      }

      // 新しいレイヤー<g>を追加する。
      newLayer(id) {
        this.lastLayer = this.$NS("g").appendTo(this.$svg);
        if (id != null) {
          this.lastLayer.attr('id', id);
        }
        return this.lastLayer[0];
      }

      // SVGの<path>要素を作る。
      newPath(type, data) {
        var $p, i, o;
        $p = this.$NS("path", {
          class: type,
          d: ((function() {
            var j, len1, results;
            results = [];
            for (i = j = 0, len1 = data.length; j < len1; i = ++j) {
              o = data[i];
              results.push(i === 0 ? `M${o.x},${o.y} L` : `${o.x},${o.y} `);
            }
            return results;
          })()).join("")
        }).appendTo(this.lastLayer);
        return $p[0];
      }

      // SVGの<text>要素を作る。
      newText(type, pos, anchor, str) {
        var $t;
        $t = this.$NS("text", {
          class: type,
          x: pos.x,
          y: pos.y
        });
        switch (anchor) {
          case "E":
            $t.css({
              "text-anchor": "start",
              "dominant-baseline": "central"
            });
            break;
          case "SW":
            $t.css({
              "text-anchor": "end",
              "dominant-baseline": "hanging"
            });
            break;
          case "S":
            $t.css({
              "text-anchor": "middle",
              "dominant-baseline": "hanging"
            });
            break;
          case "W":
            $t.css({
              "text-anchor": "end",
              "dominant-baseline": "central" // "N"
            });
            break;
          default:
            $t.css({
              "text-anchor": "middle"
            });
        }
        $t.text(str);
        $t.appendTo(this.lastLayer);
        return $t[0];
      }

    };

    // スタイル要素を設定する。
    SVGGenerator.property('css', {
      set: function(data) {
        return this.$svg.find("style").text(_toStyleString(data));
      }
    });

    // SVGファイルを構成する文字列を作る。
    SVGGenerator.property('html', {
      get: function() {
        return '<?xml version="1.0" encoding="UTF-8"?>' + this.$svg[0].outerHTML;
      }
    });

    SVGGenerator.property('dom', {
      get: function() {
        return this.$svg[0];
      }
    });

    //#--------------------------------------------------------------------
    // static private
    _NS = "http://www.w3.org/2000/svg";

    // オブジェクトをCSS文字列に変換する。
    _toStyleString = function(obj) {
      var buf, data, o, one;
      if ((typeof data) === 'string') {
        return obj;
      }
      buf = "";
      for (one in obj) {
        buf += `${one} { `;
        data = obj[one];
        for (o in data) {
          buf += `${o}:${data[o]}; `;
        }
        buf += " } ";
      }
      return buf;
    };

    return SVGGenerator;

  }).call(this);

  //#==============================================================================
  // 画像キャッシュサーバー
  // JQueryを利用する。
  ImageServer = class ImageServer {
    // store は非表示の <div> 要素。<canvas>のキャッシュが貯まる。
    // checker は、URLを受け取り、正か負を返す関数。
    // 負を返すと画像がキャッシュから消去される
    constructor(store, _checker) {
      this._checker = _checker;
      this._$s = $(store);
    }

    // urlの画像を読み込み、cb(canvas)で呼び出す。
    // エラー時には、errorcb が呼び出される。
    loadImage(url, cb, errorcb) {
      var $can, $img, outer;
      $can = this._$s.children('canvas[src="' + url + '"]');
      if (0 < $can.length) {
        // console.log "do recycle #{url}"
        return cb($can[0]);
      } else {
        outer = this;
        // console.log "start loading of #{url}"
        return $img = $("<img>").attr("crossOrigin", "Anonymous").on("load", function(e) {
          var ctx, img;
          // console.log "load completed"
          img = e.target;
          $can = $("<canvas>").attr({
            width: img.width,
            height: img.height,
            src: img.src
          });
          ctx = $can[0].getContext('2d');
          ctx.drawImage(img, 0, 0);
          // 古いのを削除する。
          outer._$s.children('canvas').each(function(idx) {
            var $t, u;
            $t = $(this);
            u = $t.attr("src");
            if (!outer._checker(u)) {
              return $t.remove();
            }
          });
          outer._$s.append($can);
          return cb($can[0]);
        }).on("error", errorcb).attr("src", url);
      }
    }

  };

  //###############################################################################
  // Leaflet ラッパ。jQueryを利用します。
  // 国土地理院地図を利用し、日本を表示します。
  // データ書式
  // { lat: 緯度, lng: 経度, x: 距離, y: 標高, label: ラベル, pitch: 傾斜 }
  // pitch は付近の等高線のつまり具合の指標を表す。

  //#==============================================================================
  // extends L.Point
  // 長さ
  L.Point.property('length', {
    get: function() {
      return Math.sqrt(this.x * this.x + this.y * this.y);
    }
  });

  // 正規化
  L.Point.prototype.normalized = function() {
    var l;
    l = this.length;
    return L.point(this.x / l, this.y / l);
  };

  // 内積
  L.Point.prototype.dotOf = function(p2) {
    return this.x * p2.x + this.y * p2.y;
  };

  // 外積
  L.Point.prototype.crossOf = function(p2) {
    return this.x * p2.y - this.y * p2.x;
  };

  // 点が線分上にあるか
  L.Point.prototype.isOnTheLineOf = function(p1, p3, crossBorder) {
    var nv21, nv31, v21, v31;
    if (crossBorder == null) {
      crossBorder = 0.1;
    }
    v21 = this.subtract(p1);
    v31 = p3.subtract(p1);
    nv21 = v21.normalized();
    nv31 = v31.normalized();
    return v21.length < v31.length && 0 < v21.dotOf(v31) && Math.abs(nv31.crossOf(nv21)) < crossBorder;
  };

  GSIMap = (function() {
    var EARTH_CIRCLE, EARTH_RADIUS, TO_RADIAN;

    //#==============================================================================
    // Leafletの国土地理院地図チューン
    class GSIMap extends L.Map {
      constructor(id) {
        super(id);
        // マップ右下のリンクを出す。
        L.tileLayer('https://cyberjapandata.gsi.go.jp/xyz/std/{z}/{x}/{y}.png', {
          attribution: '<a href="https://maps.gsi.go.jp/development/ichiran.html" target="_blank">地理院タイル</a>',
          maxZoom: 18
        }).addTo(this);
        // 日本を表示する。
        this.resetDefaultLocation();
      }

      // マップを初期状態にする。
      resetDefaultLocation() {
        return this.setView([36.104611, 140.084556], 5);
      }

      //#--------------------------------------------------------------------
      // static

      // あるズームレベルにおけるマップの全サイズ(ピクセル)
      static MAP_SIZE(z) {
        return 256 * (2 ** z);
      }

      // 指定のズームレベル、緯度で1pixelが何メートルになるか。
      // ただし、地球は球であると近似する。
      static getLengthOfPixel(zoom, lat) {
        return EARTH_CIRCLE * Math.cos(lat * TO_RADIAN) / GSIMap.MAP_SIZE(zoom);
      }

      // 全タイル内での位置から、現在のタイル位置を得る。
      static getTileXYFromCoord(p) {
        return L.point(Math.floor(p.x / 256), Math.floor(p.y / 256));
      }

      // 全タイル内での位置から、現在のタイル左上を原点とする位置に変換する。
      static getPointOnTileFromCoord(p) {
        return new L.Point(Math.floor(p.x % 256), Math.floor(p.y % 256));
      }

      // タイル位置から、標高タイル画像のURLを得る。
      static getDEMURLFromTileXY(p, zoom) {
        if ((0 <= zoom && zoom <= 14)) {
          return `${GSIMap.URL}dem_png/${zoom}/${p.x}/${p.y}.png`;
        } else {
          return `${GSIMap.URL}dem5a_png/15/${p.x}/${p.y}.png`;
        }
      }

      // URLからタイル情報を得る。
      // {zoom:, x:, y:}
      static getTileInfoFromURL(url) {
        return JSON.parse(url.replace(/.*\/(\d+)\/(\d+)\/(\d+)\.png$/, '{"zoom":$1, "x":$2, "y":$3}'));
      }

    };

    GSIMap.URL = "https://cyberjapandata.gsi.go.jp/xyz/";

    //#--------------------------------------------------------------------
    // static private

    // 地球の半径(m)(赤道の値。ただし、ここで地球は真球と近似する。)
    // https://ja.wikipedia.org/wiki/%E5%9C%B0%E7%90%83%E5%8D%8A%E5%BE%84
    EARTH_RADIUS = 6378136.6;

    // 地球の円周
    EARTH_CIRCLE = EARTH_RADIUS * 2 * Math.PI;

    // degree to radian
    TO_RADIAN = Math.PI / 180;

    return GSIMap;

  }).call(this);

  //#==============================================================================
  // ルート全体(赤い線)
  RouteMarkerGenerator = class RouteMarkerGenerator extends L.Polyline {
    // map is L.Map
    // hs is HeightServer
    constructor(_map, _hs) {
      super([], {
        color: 'red'
      });
      this._map = _map;
      this._hs = _hs;
      this._markers = [];
      this.addTo(this._map);
      this.on('click', function(e) {
        var pos;
        pos = this._find(e.latlng);
        if (0 < pos) {
          this.create(e.latlng, pos);
        }
        return L.DomEvent.stopPropagation(e);
      });
    }

    // マーカーを表示する。
    show() {
      if (0 < this._markers.length) {
        return $(this._markers[0].getPane()).show();
      }
    }

    // マーカーを隠す。
    hide() {
      if (0 < this._markers.length) {
        return $(this._markers[0].getPane()).hide();
      }
    }

    // マーカーに合わせて赤い線を更新する。
    update() {
      var m;
      return this.setLatLngs((function() {
        var j, len1, ref, results;
        ref = this._markers;
        results = [];
        for (j = 0, len1 = ref.length; j < len1; j++) {
          m = ref[j];
          results.push(m.getLatLng());
        }
        return results;
      }).call(this));
    }

    // 全消去
    clearAll() {
      var j, len1, one, ref;
      ref = this._markers;
      for (j = 0, len1 = ref.length; j < len1; j++) {
        one = ref[j];
        one.remove();
      }
      this._markers = [];
      return this.setLatLngs([]);
    }

    // 一括読み込み。
    load(data) {
      var j, len1, m, one, results;
      this.clearAll();
      results = [];
      for (j = 0, len1 = data.length; j < len1; j++) {
        one = data[j];
        m = this.create(one);
        if (one.label != null) {
          m.title = one.label;
        }
        if (one.y != null) {
          m.height = one.y;
        }
        if (one.pitch != null) {
          results.push(m.pitch = one.pitch);
        } else {
          results.push(void 0);
        }
      }
      return results;
    }

    // latlng の位置、idx の順番にマーカーを追加する。
    // idx を省略した場合は最後に追加される。
    create(latlng, idx) {
      var m;
      m = new RouteMarker(this, latlng).addTo(this._map);
      if (idx != null) {
        this._markers.splice(idx, 0, m);
      } else {
        this._markers.push(m);
      }
      this.update();
      return m;
    }

    // ドラッグ中は他のマーカーを消す。
    dragStart(m) {
      var j, len1, one, ref, results;
      ref = this._markers;
      results = [];
      for (j = 0, len1 = ref.length; j < len1; j++) {
        one = ref[j];
        if (one !== m) {
          results.push(one.setOpacity(0));
        } else {
          results.push(void 0);
        }
      }
      return results;
    }

    // ドラッグが終ったらマーカーを表示する。
    dragEnd() {
      var j, len1, one, ref, results;
      ref = this._markers;
      results = [];
      for (j = 0, len1 = ref.length; j < len1; j++) {
        one = ref[j];
        results.push(one.setOpacity(1.0));
      }
      return results;
    }

    // マーカーを消す。
    remove(m) {
      this._markers = this._markers.filter((one) => {
        return one !== m;
      });
      m.remove();
      return this.update();
    }

    // マーカーのバルーンに標高値と傾斜を設定する。
    queryHeightAndPitch(m, cb) {
      var height, pitch;
      height = m.height;
      pitch = m.pitch;
      if (isNaN(height) || isNaN(pitch)) {
        return this._hs.getHeightAndPitchFromLatLng(m.getLatLng(), 15, function(h, p) {
          m.height = h;
          m.pitch = p;
          return typeof cb === "function" ? cb(h, p) : void 0;
        });
      } else {
        return typeof cb === "function" ? cb(height, pitch) : void 0;
      }
    }

    // 全てのマーカーに標高、傾斜を設定し、コールバックを呼び出す。
    // cb([L.Markers])
    queryAllHeightAndPitch(progressbar, cb) {
      var $bar, outer, proc, progress;
      outer = this;
      $bar = $(progressbar).attr({
        max: this._markers.length,
        value: 0
      });
      progress = -1;
      proc = function() {
        ++progress;
        $bar.val(progress);
        if (progress < outer._markers.length) {
          return outer.queryHeightAndPitch(outer._markers[progress], proc);
        } else {
          $bar.val(0);
          return cb(outer._markers);
        }
      };
      return proc();
    }

    // lls ルート上の点 latlng が含まれる線分のインデックスを返す。
    // みつからなければ -1 を返す。
    _find(latlng) {
      var idx, j, len1, ll, lls, p1, p2, p3;
      p2 = this._map.project(latlng);
      lls = this.getLatLngs();
      for (idx = j = 0, len1 = lls.length; j < len1; idx = ++j) {
        ll = lls[idx];
        if (lls.length <= idx + 1) {
          break;
        }
        p1 = this._map.project(ll);
        p3 = this._map.project(lls[idx + 1]);
        if (p2.isOnTheLineOf(p1, p3)) {
          return idx + 1;
        }
      }
      return -1;
    }

  };

  RouteMarker = (function() {
    //#==============================================================================
    // ルートマーカー
    class RouteMarker extends L.Marker {
      //#--------------------------------------------------------------------
      // public

      // g は RouteMarkerGenerator
      // latlng は位置
      constructor(_g, latlng) {
        var outer;
        super(latlng, {
          riseOnHover: true,
          draggable: true
        });
        this._g = _g;
        outer = this;
        // 中身
        this._$c = $("<div><input type='text' class='title'></input><br> 緯度軽度: <span class='latlng'></span><br> 標高: <input type='text' class='height' val='N/A'></input>m<br> 傾斜: <span class='pitch'>N/A</span><br> <button>削除</button></div>");
        // 削除ボタン
        this._$c.find("button").on("click", function(e) {
          return outer._g.remove(outer);
        });
        // テキストボックスで ESC を押したらバルーンを閉じる。
        this._$c.find("input").on("keyup", function(e) {
          if (e.keyCode === 0x1b) {
            outer.closePopup();
            return e.preventDefault();
          }
        });
        this.bindPopup(this._$c[0]);
        this.on('click', function(e) {
          var ll;
          ll = this.getLatLng();
          this._$c.find("span.latlng").text(`${ll.lat.toFixed(2)}, ${ll.lng.toFixed(2)}`);
          return this._g.queryHeightAndPitch(this, function() {
            return outer._$c.find("input.title").focus();
          });
        });
        this.on('drag', function(e) {
          return this._g.update();
        });
        this.on('dragstart', function(e) {
          return this._g.dragStart(this);
        });
        this.on('dragend', function(e) {
          this.height = "N/A";
          this.pitch = "N/A";
          return this._g.dragEnd();
        });
      }

    };

    // バルーンのタイトルを得る。
    RouteMarker.property('title', {
      get: function() {
        return this._$c.find("input.title").val();
      },
      set: function(s) {
        return this._$c.find("input.title").val(s);
      }
    });

    // バルーン内の標高を得る。
    RouteMarker.property('height', {
      get: function() {
        var val;
        val = this._$c.find("input.height").val();
        if (!val) {
          return Number.NaN;
        } else {
          return parseFloat(val);
        }
      },
      set: function(h) {
        return this._$c.find("input.height").val((typeof h) === 'number' ? h.toFixed(2) : h);
      }
    });

    // バルーン内の傾斜を得る。
    RouteMarker.property('pitch', {
      get: function() {
        return parseFloat(this._$c.find("span.pitch").text());
      },
      set: function(p) {
        return this._$c.find("span.pitch").text((typeof p) === 'number' ? p.toFixed(2) : p);
      }
    });

    return RouteMarker;

  }).call(this);

  HeightServer = (function() {
    var _getHeightFromImg, _getHeightFromRGB, _getPitchFromImg;

    //#==============================================================================
    // 標高サーバー
    // 国土地理院地図の標高マップから標高値を得る。
    class HeightServer {
      constructor(_map, _is) {
        this._map = _map;
        this._is = _is;
      }

      // 標高と傾斜を得る。
      getHeightAndPitchFromLatLng(latlng, zoom, cb) {
        var coord, outer, p, url;
        coord = this._map.project(latlng, zoom);
        url = GSIMap.getDEMURLFromTileXY(GSIMap.getTileXYFromCoord(coord), zoom);
        p = GSIMap.getPointOnTileFromCoord(coord);
        outer = this;
        return this._is.loadImage(url, function(canvas) {
          var h;
          h = _getHeightFromImg(canvas, p);
          if (isNaN(h) && zoom === 15) {
            return outer.getHeightAndPitchFromLatLng(latlng, 14, cb);
          } else {
            return cb(h, _getPitchFromImg(canvas, p, zoom, latlng.lat));
          }
        }, function(e) { // 失敗したら10mBメッシュで取り直し。
          if (zoom < 15) {
            return cb(Number.NaN, 0);
          } else {
            return outer.getHeightAndPitchFromLatLng(latlng, 14, cb);
          }
        });
      }

    };

    //#--------------------------------------------------------------------
    // static private

    // RGBデータから標高を得る。(単位はm)
    _getHeightFromRGB = function(rgb) {
      var x;
      x = (rgb[0] << 16) + (rgb[1] << 8) + rgb[2];
      if (x < (1 << 23)) {
        return x * 0.01;
      } else if ((1 << 23) < x) {
        return (x - 1 << 24) * 0.01;
      } else {
        return Number.NaN;
      }
    };

    // canvas要素から p の位置の標高を得る。
    _getHeightFromImg = function(canvas, p) {
      return _getHeightFromRGB(canvas.getContext('2d').getImageData(p.x, p.y, 1, 1).data);
    };

    // canvas要素から p の位置の傾斜情報を得る。
    _getPitchFromImg = function(canvas, p, zoom, lat) {
      var data, h, i, j, max, min, ref, truncatedRatio;
      data = canvas.getContext('2d').getImageData(p.x - 1, p.y - 1, 3, 3).data;
      max = -999999;
      min = 999999;
      truncatedRatio = 1; // 画像端の場合の調整
      for (i = j = 0, ref = data.length; j <= ref; i = j += 4) {
        if (data[i + 3] === 0) { // 透明ピクセルは範囲外
          truncatedRatio = 2;
          continue;
        }
        h = _getHeightFromRGB(data.slice(i));
        if (max < h) {
          max = h;
        }
        if (h < min) {
          min = h;
        }
      }
      if (max <= min) {
        return 0;
      } else {
        return (max - min) * truncatedRatio / 2 / GSIMap.getLengthOfPixel(zoom, lat);
      }
    };

    return HeightServer;

  }).call(this);

  //#==============================================================================
  // [{x: 距離, y: 標高, label: ラベル, pitch: 傾斜}, ...]からSVGを出力する。
  // jQueryを利用する。
  makeSVG = function(data) {
    var d, graphMargin, graphSize, graphTopLeft, isUpper, j, k, len, len1, len2, len3, maxHeight, maxLength, maxX, maxY, minHeight, minY, n, one, pitchOnGraph, pitchPosOnGraph, posOnGraph, prevX, q, ref, ref1, ref2, scaleX, scaleY, svgg, x, xOnGraph, y, yOnGraph;
    // 定数
    graphSize = {
      x: 230,
      y: 160
    };
    graphTopLeft = {
      x: 30,
      y: 20
    };
    graphMargin = {
      top: 10,
      bottom: 10,
      left: 0,
      right: 10
    };
    // 情報
    maxLength = 0;
    minHeight = 99999;
    maxHeight = -99999;
    scaleX = 1;
    scaleY = 1;
    // dataの値をSVG内での位置に変換する。
    xOnGraph = function(x) {
      return graphTopLeft.x + graphMargin.left + x * scaleX;
    };
    yOnGraph = function(y) {
      return graphTopLeft.y + graphSize.y - graphMargin.bottom - (y - minHeight) * scaleY;
    };
    posOnGraph = function(p) {
      return {
        x: xOnGraph(p.x),
        y: yOnGraph(p.y)
      };
    };
    // 傾斜の変換
    pitchOnGraph = function(inc) {
      return graphTopLeft.y + graphSize.y - graphMargin.bottom - inc * inc * 40;
    };
    pitchPosOnGraph = function(p) {
      return {
        x: xOnGraph(p.x),
        y: pitchOnGraph(p.pitch)
      };
    };
    //#--------------------------------------------------------------------
    // データ解析
    maxLength = data[data.length - 1].x;
    for (j = 0, len1 = data.length; j < len1; j++) {
      one = data[j];
      if (one.y < minHeight) {
        minHeight = one.y;
      }
      if (maxHeight < one.y) {
        maxHeight = one.y;
      }
    }
    scaleX = (graphSize.x - graphMargin.left - graphMargin.right) / maxLength;
    scaleY = (graphSize.y - graphMargin.top - graphMargin.bottom) / (maxHeight - minHeight);
    //#--------------------------------------------------------------------
    // 描画
    //#--------------------------------------------------------------------

    svgg = new SVGGenerator('A4');
    svgg.css = {
      'path': {
        fill: 'none',
        'stroke-linecap': 'butt',
        'stroke-linejoin': 'miter',
        'stroke-opacity': 1
      },
      '.data': {
        stroke: '#000000',
        'stroke-width': 0.4
      },
      '.pitch': {
        stroke: '#ff8080',
        'stroke-width': 0.4
      },
      '.bg': {
        fill: 'white',
        stroke: 'none'
      },
      '.frame': {
        stroke: '#000000',
        'stroke-width': 0.8
      },
      '.scale': {
        'font-size': '3.5pt'
      },
      '.label': {
        'font-size': '4pt'
      },
      '.label-guide': {
        stroke: '#808080',
        'stroke-width': 0.2
      }
    };
    // レイヤー1
    svgg.newLayer();
    // 外枠
    svgg.newPath("bg", [
      {
        x: 0,
        y: 0
      },
      {
        x: 0,
        y: svgg.paperSize.y
      },
      {
        x: svgg.paperSize.x,
        y: svgg.paperSize.y
      },
      {
        x: svgg.paperSize.x,
        y: 0
      },
      {
        x: 0,
        y: 0
      }
    ]);
    // Lの字
    svgg.newPath("frame", [
      {
        x: graphTopLeft.x,
        y: graphTopLeft.y
      },
      {
        x: graphTopLeft.x,
        y: graphTopLeft.y + graphSize.y
      },
      {
        x: graphTopLeft.x + graphSize.x,
        y: graphTopLeft.y + graphSize.y
      }
    ]);
    // 左上(標高)
    svgg.newText("scale", graphTopLeft, "N", "標高(m)");
    // 右下(水平距離)
    svgg.newText("scale", {
      x: graphTopLeft.x + graphSize.x,
      y: graphTopLeft.y + graphSize.y
    }, "E", "距離(km)");
    // 左下(倍率)
    svgg.newText("scale", {
      x: graphTopLeft.x,
      y: graphTopLeft.y + graphSize.y
    }, "SW", ((scaleY / scaleX).toFixed(1)) + ":1");
    // 全距離
    x = xOnGraph(maxLength);
    y = graphTopLeft.y + graphSize.y;
    svgg.newPath("frame", [
      {
        x: x,
        y: y
      },
      {
        x: x,
        y: y + 5
      }
    ]);
    svgg.newText("scale opaque", {
      x: x,
      y: y + 5
    }, "S", (maxLength / 1000).toFixed(1));
    maxX = x;
    for (len = k = 1000, ref = maxLength; k <= ref; len = k += 1000) {
      x = xOnGraph(len);
      y = graphTopLeft.y + graphSize.y;
      if ((len % 5000) === 0 && 10 < (maxX - x)) {
        svgg.newPath("frame", [
          {
            x: x,
            y: y
          },
          {
            x: x,
            y: y + 5
          }
        ]);
        svgg.newText("scale", {
          x: x,
          y: y + 5
        }, "S", len / 1000);
      } else {
        svgg.newPath("frame", [
          {
            x: x,
            y: y
          },
          {
            x: x,
            y: y + 2
          }
        ]);
      }
    }
    // 最低標高
    x = graphTopLeft.x;
    y = yOnGraph(minHeight);
    svgg.newPath("frame", [
      {
        x: x - 5,
        y: y
      },
      {
        x: x,
        y: y
      }
    ]);
    svgg.newText("scale opaque", {
      x: x - 5,
      y: y
    }, "W", minHeight.toFixed(0));
    minY = y;
    y = yOnGraph(maxHeight);
    svgg.newPath("frame", [
      {
        x: x - 5,
        y: y
      },
      {
        x: x,
        y: y
      }
    ]);
    svgg.newText("scale opaque", {
      x: x - 5,
      y: y
    }, "W", maxHeight.toFixed(0));
    maxY = y;
    for (len = n = ref1 = minHeight + 100, ref2 = maxHeight; n <= ref2; len = n += 100) {
      len2 = len - (len % 100);
      x = graphTopLeft.x;
      y = yOnGraph(len2);
      svgg.newPath("frame", [
        {
          x: x - 5,
          y: y
        },
        {
          x: x,
          y: y
        }
      ]);
      if (5 < (minY - y) && 5 < (y - maxY)) {
        svgg.newText("scale", {
          x: x - 5,
          y: y
        }, "W", len2);
      }
    }
    //#--------------------------------------------------------------------
    // 傾斜
    svgg.newPath("pitch", (function() {
      var len3, q, results;
      results = [];
      for (q = 0, len3 = data.length; q < len3; q++) {
        one = data[q];
        results.push(pitchPosOnGraph(one));
      }
      return results;
    })());
    // UP-DOWN
    svgg.newPath("data", (function() {
      var len3, q, results;
      results = [];
      for (q = 0, len3 = data.length; q < len3; q++) {
        one = data[q];
        results.push(posOnGraph(one));
      }
      return results;
    })());
    //#--------------------------------------------------------------------
    // ラベル
    prevX = 0;
    isUpper = true;
    for (q = 0, len3 = data.length; q < len3; q++) {
      one = data[q];
      if (0 < one.label.length) {
        x = xOnGraph(one.x);
        if (((x - prevX) < 10) === isUpper) {
          d = 10;
          isUpper = false;
        } else {
          d = -10;
          isUpper = true;
        }
        y = yOnGraph(one.y);
        svgg.newPath("label-guide", [
          {
            x: x,
            y: y
          },
          {
            x: x,
            y: y + d
          }
        ]);
        svgg.newText("label", {
          x: x,
          y: y + d
        }, (isUpper ? "N" : "S"), one.label);
        prevX = x;
      }
    }
    return svgg;
  };

  //#==============================================================================
  // メインフレーム
  MyMap = class MyMap extends GSIMap {
    constructor(id, store, _progressbar) {
      var outer;
      super(id);
      this._progressbar = _progressbar;
      outer = this;
      this._is = new ImageServer(store, function(url) {
        return outer._visibleOnMap(GSIMap.getTileInfoFromURL(url));
      });
      this._hs = new HeightServer(this, this._is);
      this._rmg = new RouteMarkerGenerator(this, this._hs);
      // 地図上のクリックイベント
      this.on('click', function(e) {
        return this._rmg.create(e.latlng);
      });
      // シフトキーでマーカーを消す。
      $("body").on('keydown', function(e) {
        if (e.keyCode === 16) {
          return outer._rmg.hide();
        }
      }).on('keyup', function(e) {
        if (e.keyCode === 16) {
          return outer._rmg.show();
        }
      });
    }

    // 全消去
    clearAll() {
      return this._rmg.clearAll();
    }

    // 一括読み込み
    load(data) {
      return this._rmg.load(data);
    }

    // 一括書き出し
    getAllData(cb) {
      return this._rmg.queryAllHeightAndPitch(this._progressbar, function(m) {
        var i, one, wl;
        wl = 0;
        return cb((function() {
          var j, len1, results;
          results = [];
          for (i = j = 0, len1 = m.length; j < len1; i = ++j) {
            one = m[i];
            results.push({
              lat: one.getLatLng().lat,
              lng: one.getLatLng().lng,
              x: i === 0 ? 0 : wl += m[i - 1].getLatLng().distanceTo(one.getLatLng()),
              y: one.height,
              label: one.title,
              pitch: one.pitch
            });
          }
          return results;
        })());
      });
    }

    // タイルが現在の map上で見えているか。
    // tile = {x: x, y: y, zoom: zoom}
    _visibleOnMap(tile) {
      var br, mapB, ref, ref1, tl;
      mapB = this.getBounds();
      tl = GSIMap.getTileXYFromCoord(this.project(mapB.getNorthWest(), tile.zoom));
      br = GSIMap.getTileXYFromCoord(this.project(mapB.getSouthEast(), tile.zoom));
      return (tl.x <= (ref = tile.x) && ref <= br.x) && (tl.y <= (ref1 = tile.y) && ref1 <= br.y);
    }

  };

  //###############################################################################
  //#
  //# jQuery 開始
  //#
  //###############################################################################
  $(function() {
    var clearAll, closeHelp, map;
    // 説明画面
    closeHelp = function(e) {
      return $("#help").hide();
    };
    $(".closeHelp").on("click", closeHelp);
    // local storage
    if (!localStorage.getItem("secondInvocation")) {
      localStorage.setItem("secondInvocation", true);
    } else {
      closeHelp();
    }
    // UIの設定
    $("#menu").hide();
    $("#openButton").on("click", function(e) {
      $(this).hide();
      return $("#menu").show();
    });
    $("#closeButton").on("click", function(e) {
      $("#menu").hide();
      return $("#openButton").show();
    });
    // マップの初期化
    map = new MyMap("map", "#store", "#progressbar");
    // 全消去
    clearAll = function() {
      map.clearAll();
      return $("#svgcanvas").empty();
    };
    // データ作成する。
    $("#createData").on("click", function(e) {
      var sel;
      sel = ($("#dataFormat"))[0];
      switch (sel.options[sel.selectedIndex].value) {
        case "CSV":
          return map.getAllData(function(data) {
            var o;
            return $("#dataOutput").val(((function() {
              var j, len1, results;
              results = [];
              for (j = 0, len1 = data.length; j < len1; j++) {
                o = data[j];
                results.push(`${o.x.toFixed(2)}, ${o.y.toFixed(2)}, "${o.label}"`);
              }
              return results;
            })()).join("\r\n"));
          });
        case "JSON":
          return map.getAllData(function(data) {
            return $("#dataOutput").val(JSON.stringify(data));
          });
        case "SVG":
          $("#svgcanvas").empty();
          return map.getAllData(function(data) {
            var svgg;
            svgg = makeSVG(data);
            $("#svgcanvas").append(svgg.dom);
            return $("#dataOutput").val(svgg.html);
          });
      }
    });
    
    $("#clearAll").on("click", function(e) {
      return clearAll();
    });
    
    $("#loadData").on("click", function(e) {
      clearAll();
      return map.load(JSON.parse($("#dataOutput").val()));
    });
    
    return $("#showHelp").on("click", function(e) {
      return $("#help").show();
    });
  });

}).call(this);
